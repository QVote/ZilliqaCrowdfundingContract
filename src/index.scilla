scilla_version 0
import ListUtils IntUtils PairUtils
library ICOContract

@import {
    Error,
    make_error,
    one_msg,
    addfunds_tag
} from "./lib/ICOContract.scillib"

let bool_true = True

contract ICOContract(
    init_admin: ByStr20
)
(* Current contract admin *)
field contractadmin: ByStr20  = init_admin
(* Admin that can be claimed by existing address *)
field stagingcontractadmin: Option ByStr20 = None {ByStr20}

procedure ThrowError(err: Error)
    e = make_error err;
    throw e
end
procedure IsAdmin(initiator: ByStr20)
    contractadmin_tmp <- contractadmin;
    is_admin = builtin eq initiator contractadmin_tmp;
    match is_admin with
    | True  =>
    | False =>
        e = AdminValidationFailed;
        ThrowError e
    end
end
procedure TransferFunds(tag: String, amt: Uint128, recipient: ByStr20)
    msg = {_tag: tag; _recipient: recipient; _amount: amt};
    msgs = one_msg msg;
    send msgs
end
(* Update staged admin *)
transition UpdateAdmin(admin: ByStr20)
    IsAdmin _sender;
    staging_admin = Some {ByStr20} admin;
    stagingcontractadmin := staging_admin
end
(* Staged admin can claim the staged admin and become admin *)
transition ClaimAdmin()
    staging_admin <- stagingcontractadmin;
    match staging_admin with
    | Some admin =>
        is_valid = builtin eq _sender admin;
        match is_valid with
        | True =>
            contractadmin := admin;
            staging_admin = None {ByStr20};
            stagingcontractadmin := staging_admin;
            e = { _eventname: "ClaimAdmin"; new_admin: admin };
            event e
        | False =>
            e = StagingAdminValidationFailed;
            ThrowError e
        end
    | None =>
        e = StagingAdminNotExist;
        ThrowError e
    end
end
(* withdraw zils *)
(* only if is admin  *)
transition DrainContractBalance(amt: Uint128)
    IsAdmin _sender;
    bal <- _balance;
    TransferFunds addfunds_tag bal _sender;
    e = { _eventname: "DrainContractBalance"; to: _sender; amount: amt};
    event e
end